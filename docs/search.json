[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Notas e Resumos",
    "section": "",
    "text": "Minhas notas de estudo e resumos sobre ciência de dados.\n\n\n\n De volta ao topo"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "De volta ao topo"
  },
  {
    "objectID": "git.html",
    "href": "git.html",
    "title": "Github",
    "section": "",
    "text": "1 Configurar o Git\n\nusethis::create_github_token()\n\ngitcreds::gitcreds_set()\n#2: Replace these credentials\n\ngh::gh_whoami()\n\n\n\n2 Criar um repositório\n1 usethis::create_project(\".\") criar o projeto na raiz “.”\n2 criando um repositório Github local\nusethis::use_git()\n3 inserindo arquivos no projeto\n4 Criando/inserindo no repositório Github (nuvem)\nuse_this::use_github()\n\n\n\n\n De volta ao topo"
  },
  {
    "objectID": "program.html",
    "href": "program.html",
    "title": "Programação",
    "section": "",
    "text": "Vantagens de construir uma função:\n\nVocê pode dar a uma função um nome evocativo que torne seu código mais fácil de entender.\nÀ medida que os requisitos mudam, você só precisa atualizar o código em um local, em vez de vários.\nVocê elimina a chance de cometer erros acidentais ao copiar e colar (ou seja, atualizar o nome de uma variável em um local, mas não em outro).\nTorna mais fácil reutilizar o trabalho projeto a projeto, aumentando sua produtividade ao longo do tempo.\n\nTrês tipos úteis de funções\n\nAs funções vetoriais recebem um ou mais vetores como entrada e retornam um vetor como saída.\nAs funções de quadro de dados recebem um quadro de dados como entrada e retornam um quadro de dados como saída.\nFunções de plotagem que recebem um quadro de dados como entrada e retornam um gráfico como saída\n\n\n\n\nlibrary(tidyverse)\nlibrary(nycflights13)\n\n\n\n\n\ndf &lt;- tibble(\n  a = rnorm(5),\n  b = rnorm(5),\n  c = rnorm(5),\n  d = rnorm(5)\n)\n\n\ndf |&gt; mutate(\n  a = (a - min(a, na.rm = TRUE)) / \n    (max(a, na.rm = TRUE) - min(a, na.rm = TRUE)), # errado \n  b = (b - min(b, na.rm = TRUE)) / \n    (max(b, na.rm = TRUE) - min(a, na.rm = TRUE)), # errado \n  c = (c - min(c, na.rm = TRUE)) / \n    (max(c, na.rm = TRUE) - min(c, na.rm = TRUE)),\n  d = (d - min(d, na.rm = TRUE)) / \n    (max(d, na.rm = TRUE) - min(d, na.rm = TRUE)),\n)\n\n# A tibble: 5 × 4\n      a     b     c     d\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 0.390 0.116 0.683 0    \n2 0.751 1.06  0     0.537\n3 1     0.346 1     0.948\n4 0.246 0     0.301 0.672\n5 0     0.599 0.638 1    \n\n\n\n\nPrimeiramente, verificar quais partes são constantes e quais variam.\n\n#( - min( , na.rm = TRUE)) / (max( , na.rm = TRUE) - min( , na.rm = TRUE))\n\nPara transformar isso em uma função são necessários três passos:\n\nUm nome . Aqui usaremos rescale01porque esta função redimensiona um vetor para ficar entre 0 e 1.\nOs argumentos . Os argumentos variam entre as chamadas e nossa análise acima nos diz que temos apenas um. Chamaremos isso xporque este é o nome convencional para um vetor numérico.\nO corpo . O corpo é o código repetido em todas as chamadas.\n\nModelo de função\n\nname &lt;- function(arguments) {\n  body\n}\n\nLogo:\n\nrescale01 &lt;- function(x){\n  (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))\n \n}\n\n\nrescale01(c(-10,0,10))\n\n[1] 0.0 0.5 1.0\n\nrescale01(c(1,2,3,NA,5))\n\n[1] 0.00 0.25 0.50   NA 1.00\n\n\nPode-se reescrever a chamada `mutate` como:\n\ndf |&gt; mutate(\n  a = rescale01(a),\n  b = rescale01(b),\n  c = rescale01(c),\n  d = rescale01(d)\n)\n\n# A tibble: 5 × 4\n      a     b     c     d\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 0.390 0.109 0.683 0    \n2 0.751 1     0     0.537\n3 1     0.326 1     0.948\n4 0.246 0     0.301 0.672\n5 0     0.563 0.638 1    \n\n\n\n\n\nVocê pode notar que a rescale01()função faz algum trabalho desnecessário - em vez de calcular min()duas vezes e max()uma vez, poderíamos calcular o mínimo e o máximo em uma única etapa com range():\n\nrescale01 &lt;- function(x) {\n  rng &lt;- range(x, na.rm = TRUE)\n  \n  (x - rng[1]) / (rng[2] - rng[1])\n}\n\nOu você pode tentar esta função em um vetor que inclui um valor infinito:\n\nxx &lt;- c(1:10, Inf)\nrescale01(xx)\n\n [1]   0   0   0   0   0   0   0   0   0   0 NaN\n\n#&gt;  [1]   0   0   0   0   0   0   0   0   0   0 NaN\n\nEsse resultado não é particularmente útil, então poderíamos pedir range()para ignorar valores infinitos:\n\nrescale01 &lt;- function(x){\n  rng &lt;- range(xx, na.rm = TRUE, finite = TRUE)\n  \n  (x -rng[1])/(rng[2]-rng[1])\n}\n\n\nrescale01(xx)\n\n [1] 0.0000000 0.1111111 0.2222222 0.3333333 0.4444444 0.5555556 0.6666667\n [8] 0.7777778 0.8888889 1.0000000       Inf\n\n\n\n\n\nFunções que utilizam mutate() e filter().\nCalculando o score z, redimensionando um vetor para ter uma média zero e um desvio padrão um.\n\nz_score &lt;- function(x){\n  (x - mean(x, na.rm = TRUE))/sd(x, na.rm = TRUE)\n}\n\nOu talvez você queira resumir algo simples case_when()e dar-lhe um nome útil. Por exemplo, esta clamp()função garante que todos os valores de um vetor estejam entre um mínimo ou um máximo:\n\nclamp &lt;- function(x, min, max){\n  case_when(\n    x &lt; min ~ min,\n    x &gt; max ~ max,\n    .default = x\n  )\n}\n\n\nclamp(1:10, min = 3, max = 7)\n\n [1] 3 3 3 4 5 6 7 7 7 7\n\n\nVocê pode querer fazer alguma manipulação repetida de strings. Talvez você precise colocar o primeiro caractere em maiúscula:\n\nstr_sub() extrai ou substitui os elementos em uma única posição em cada string.\n\n\nfirst_upper &lt;- function(x){\n  str_sub(x, 1, 1) &lt;- str_to_upper(str_sub(x,1,1)) # do 1 até 1, ou seja a primeira letra.\n  \n  x\n}\n\n\nfirst_upper(\"primeira maiúscula\")\n\n[1] \"Primeira maiúscula\"\n\n\nOu talvez você queira retirar sinais de porcentagem, vírgulas e cifrões de uma string antes de convertê-la em um número:\n\nclean_number &lt;- function(x){\n  is_pct &lt;- str_detect(x, '%')#Detectar a presença/ausência de uma correspondência\n  num &lt;- x |&gt;\n    str_remove_all(\"%\")|&gt;\n    str_remove_all(\",\")|&gt;\n    str_remove_all(fixed(\"$\"))|&gt;\n    as.numeric(x)\n  if_else(is_pct, num/100, num)\n}\n\n\nclean_number(\"$12,300\")\n\n[1] 12300\n\nclean_number(\"45%\")\n\n[1] 0.45\n\n\nPor exemplo, se você tiver um monte de variáveis ​​que registram valores ausentes como 997, 998 ou 999, você pode querer escrever uma função para substituí-los por NA:\n\nfix_na &lt;- function(x){\n  if_else(x %in% c(997,998,999), NA, x)\n}"
  },
  {
    "objectID": "program.html#pacotes",
    "href": "program.html#pacotes",
    "title": "Programação",
    "section": "",
    "text": "library(tidyverse)\nlibrary(nycflights13)"
  },
  {
    "objectID": "program.html#funções-vetoriais",
    "href": "program.html#funções-vetoriais",
    "title": "Programação",
    "section": "",
    "text": "df &lt;- tibble(\n  a = rnorm(5),\n  b = rnorm(5),\n  c = rnorm(5),\n  d = rnorm(5)\n)\n\n\ndf |&gt; mutate(\n  a = (a - min(a, na.rm = TRUE)) / \n    (max(a, na.rm = TRUE) - min(a, na.rm = TRUE)), # errado \n  b = (b - min(b, na.rm = TRUE)) / \n    (max(b, na.rm = TRUE) - min(a, na.rm = TRUE)), # errado \n  c = (c - min(c, na.rm = TRUE)) / \n    (max(c, na.rm = TRUE) - min(c, na.rm = TRUE)),\n  d = (d - min(d, na.rm = TRUE)) / \n    (max(d, na.rm = TRUE) - min(d, na.rm = TRUE)),\n)\n\n# A tibble: 5 × 4\n      a     b     c     d\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 0.390 0.116 0.683 0    \n2 0.751 1.06  0     0.537\n3 1     0.346 1     0.948\n4 0.246 0     0.301 0.672\n5 0     0.599 0.638 1    \n\n\n\n\nPrimeiramente, verificar quais partes são constantes e quais variam.\n\n#( - min( , na.rm = TRUE)) / (max( , na.rm = TRUE) - min( , na.rm = TRUE))\n\nPara transformar isso em uma função são necessários três passos:\n\nUm nome . Aqui usaremos rescale01porque esta função redimensiona um vetor para ficar entre 0 e 1.\nOs argumentos . Os argumentos variam entre as chamadas e nossa análise acima nos diz que temos apenas um. Chamaremos isso xporque este é o nome convencional para um vetor numérico.\nO corpo . O corpo é o código repetido em todas as chamadas.\n\nModelo de função\n\nname &lt;- function(arguments) {\n  body\n}\n\nLogo:\n\nrescale01 &lt;- function(x){\n  (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))\n \n}\n\n\nrescale01(c(-10,0,10))\n\n[1] 0.0 0.5 1.0\n\nrescale01(c(1,2,3,NA,5))\n\n[1] 0.00 0.25 0.50   NA 1.00\n\n\nPode-se reescrever a chamada `mutate` como:\n\ndf |&gt; mutate(\n  a = rescale01(a),\n  b = rescale01(b),\n  c = rescale01(c),\n  d = rescale01(d)\n)\n\n# A tibble: 5 × 4\n      a     b     c     d\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 0.390 0.109 0.683 0    \n2 0.751 1     0     0.537\n3 1     0.326 1     0.948\n4 0.246 0     0.301 0.672\n5 0     0.563 0.638 1    \n\n\n\n\n\nVocê pode notar que a rescale01()função faz algum trabalho desnecessário - em vez de calcular min()duas vezes e max()uma vez, poderíamos calcular o mínimo e o máximo em uma única etapa com range():\n\nrescale01 &lt;- function(x) {\n  rng &lt;- range(x, na.rm = TRUE)\n  \n  (x - rng[1]) / (rng[2] - rng[1])\n}\n\nOu você pode tentar esta função em um vetor que inclui um valor infinito:\n\nxx &lt;- c(1:10, Inf)\nrescale01(xx)\n\n [1]   0   0   0   0   0   0   0   0   0   0 NaN\n\n#&gt;  [1]   0   0   0   0   0   0   0   0   0   0 NaN\n\nEsse resultado não é particularmente útil, então poderíamos pedir range()para ignorar valores infinitos:\n\nrescale01 &lt;- function(x){\n  rng &lt;- range(xx, na.rm = TRUE, finite = TRUE)\n  \n  (x -rng[1])/(rng[2]-rng[1])\n}\n\n\nrescale01(xx)\n\n [1] 0.0000000 0.1111111 0.2222222 0.3333333 0.4444444 0.5555556 0.6666667\n [8] 0.7777778 0.8888889 1.0000000       Inf\n\n\n\n\n\nFunções que utilizam mutate() e filter().\nCalculando o score z, redimensionando um vetor para ter uma média zero e um desvio padrão um.\n\nz_score &lt;- function(x){\n  (x - mean(x, na.rm = TRUE))/sd(x, na.rm = TRUE)\n}\n\nOu talvez você queira resumir algo simples case_when()e dar-lhe um nome útil. Por exemplo, esta clamp()função garante que todos os valores de um vetor estejam entre um mínimo ou um máximo:\n\nclamp &lt;- function(x, min, max){\n  case_when(\n    x &lt; min ~ min,\n    x &gt; max ~ max,\n    .default = x\n  )\n}\n\n\nclamp(1:10, min = 3, max = 7)\n\n [1] 3 3 3 4 5 6 7 7 7 7\n\n\nVocê pode querer fazer alguma manipulação repetida de strings. Talvez você precise colocar o primeiro caractere em maiúscula:\n\nstr_sub() extrai ou substitui os elementos em uma única posição em cada string.\n\n\nfirst_upper &lt;- function(x){\n  str_sub(x, 1, 1) &lt;- str_to_upper(str_sub(x,1,1)) # do 1 até 1, ou seja a primeira letra.\n  \n  x\n}\n\n\nfirst_upper(\"primeira maiúscula\")\n\n[1] \"Primeira maiúscula\"\n\n\nOu talvez você queira retirar sinais de porcentagem, vírgulas e cifrões de uma string antes de convertê-la em um número:\n\nclean_number &lt;- function(x){\n  is_pct &lt;- str_detect(x, '%')#Detectar a presença/ausência de uma correspondência\n  num &lt;- x |&gt;\n    str_remove_all(\"%\")|&gt;\n    str_remove_all(\",\")|&gt;\n    str_remove_all(fixed(\"$\"))|&gt;\n    as.numeric(x)\n  if_else(is_pct, num/100, num)\n}\n\n\nclean_number(\"$12,300\")\n\n[1] 12300\n\nclean_number(\"45%\")\n\n[1] 0.45\n\n\nPor exemplo, se você tiver um monte de variáveis ​​que registram valores ausentes como 997, 998 ou 999, você pode querer escrever uma função para substituí-los por NA:\n\nfix_na &lt;- function(x){\n  if_else(x %in% c(997,998,999), NA, x)\n}"
  }
]